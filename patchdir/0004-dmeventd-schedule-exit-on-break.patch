From 22e1be956fdf197dcfac4ede68b5f8f09aab4a04 Mon Sep 17 00:00:00 2001
From: Zdenek Kabelac <zkabelac@redhat.com>
Date: Wed, 4 Oct 2017 13:58:21 +0200
Subject: [PATCH 4/6] dmeventd: schedule exit on break
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When dmeventd receives SIGTERM/INT/HUP/QUIT it validates if exit is possible.
If there was any device still monitored, such exit request used to
be ignored/refused. This 'usually' worked reasonably well, however if there
is very short time period between last device is unmonitored and signal
reception - there was possibility such EXIT was ignored, as dmeventd has
not yet got into idle state even commands like 'vgchange -an' has already
finished.

This patch changes logic towards scheduling EXIT to the nearest
point when there is no monitored device.

EXIT is never forgotten.

NOTE: if there is only a single monitored device and someone sends
SIGTERM and later someone uses i.e. 'lvchange --refresh' after
unmonitoring dmeventd will exit and new instance needs to be
started.

cherry picked from commit 9940c2f754e3292b6d96628682c254941ae6cc58

Signed-off-by: Thomas Lamprecht <t.lamprecht@proxmox.com>
Signed-off-by: Fabian Gr√ºnbichler <f.gruenbichler@proxmox.com>
---
 daemons/dmeventd/dmeventd.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/daemons/dmeventd/dmeventd.c b/daemons/dmeventd/dmeventd.c
index 1565b80..a16cb1f 100644
--- a/daemons/dmeventd/dmeventd.c
+++ b/daemons/dmeventd/dmeventd.c
@@ -62,6 +62,8 @@
 
 #include <syslog.h>
 
+#define DM_SIGNALED_EXIT  1
+#define DM_SCHEDULED_EXIT 2
 static volatile sig_atomic_t _exit_now = 0;	/* set to '1' when signal is given to exit */
 
 /* List (un)link macros. */
@@ -1750,7 +1752,7 @@ static void _init_thread_signals(void)
  */
 static void _exit_handler(int sig __attribute__((unused)))
 {
-	_exit_now = 1;
+	_exit_now = DM_SIGNALED_EXIT;
 }
 
 #ifdef __linux__
@@ -2248,6 +2250,8 @@ int main(int argc, char *argv[])
 	for (;;) {
 		if (_idle_since) {
 			if (_exit_now) {
+				if (_exit_now == DM_SCHEDULED_EXIT)
+					break; /* Only prints shutdown message */
 				log_info("dmeventd detected break while being idle "
 					 "for %ld second(s), exiting.",
 					 (long) (time(NULL) - _idle_since));
@@ -2263,15 +2267,14 @@ int main(int argc, char *argv[])
 					break;
 				}
 			}
-		} else if (_exit_now) {
-			_exit_now = 0;
+		} else if (_exit_now == DM_SIGNALED_EXIT) {
+			_exit_now = DM_SCHEDULED_EXIT;
 			/*
 			 * When '_exit_now' is set, signal has been received,
 			 * but can not simply exit unless all
 			 * threads are done processing.
 			 */
-			log_warn("WARNING: There are still devices being monitored.");
-			log_warn("WARNING: Refusing to exit.");
+			log_info("dmeventd received break, scheduling exit.");
 		}
 		_process_request(&fifos);
 		_cleanup_unused_threads();
-- 
2.14.1

